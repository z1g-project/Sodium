(()=>{function k(e,t){return e.split(", ").map(n=>n.split(" ").map((r,o)=>o===0?self.$meteor.rewrite.url.encode(r,t):r).join(" ")).join(", ")}function c(e,t){return new Proxy(e,{apply(n,r,o){let s=t(o);return Reflect.apply(n,r,s)}})}function y(e,t){return new Proxy(e,{construct(n,r,o){let s=t(r);return Reflect.construct(n,s,o)}})}var H={src:[HTMLScriptElement,HTMLMediaElement,HTMLImageElement,HTMLIFrameElement,HTMLSourceElement],href:[HTMLAnchorElement,HTMLLinkElement],action:[HTMLFormElement],formaction:[HTMLInputElement],data:[HTMLObjectElement]},A=["nonce","integrity","csp"];for(let[e,t]of Object.entries(H))for(let n of t){let r=Object.getOwnPropertyDescriptor(n.prototype,e);Object.defineProperty(n.prototype,e,{get(){return self.$meteor.rewrite.url.decode(r.get.call(this))},set(o){o=self.$meteor.rewrite.url.encode(o,new URL(self.$location.origin)),r.set.call(this,o)}})}var V=Object.getOwnPropertyDescriptor(Element.prototype,"innerHTML");Object.defineProperty(Element.prototype,"innerHTML",{set(e){return this instanceof HTMLScriptElement?e=self.$meteor.rewrite.js(e,new URL(self.$location.origin)):this instanceof HTMLStyleElement&&(e=self.$meteor.rewrite.css(e,new URL(self.$location.origin))),V.set.call(this,e)}});var U=Object.getOwnPropertyDescriptor(HTMLImageElement.prototype,"srcset");Object.defineProperty(HTMLImageElement.prototype,"srcset",{get(){return U.get.call(this)},set(e){e=k(e,new URL(self.$location.origin)),U.set.call(this,e)}});Element.prototype.getAttribute=c(Element.prototype.getAttribute,([e])=>A.includes(e)?null:[e]);Element.prototype.setAttribute=c(Element.prototype.setAttribute,([e,t])=>A.includes(e)?[e,""]:(H[e]&&(t=self.$meteor.rewrite.url.encode(t,new URL(self.$location.origin))),e==="style"&&(t=self.$meteor.rewrite.css(t,new URL(self.$location.origin))),e.includes("srcset")&&(t=k(t,new URL(self.$location.origin))),[e,t]));var z=["background","background-image","mask","mask-image","list-style","list-style-image","border-image","border-image-source","cursor"];CSSStyleDeclaration.prototype.setProperty=c(CSSStyleDeclaration.prototype.setProperty,([e,t,...n])=>(z.includes(e)&&(t=self.$meteor.rewrite.css(t,new URL(self.$location.origin))),[e,t,...n]));window.$location=Object.create(window.location);Object.defineProperties(window.$location,{toString:{value(){return self.$meteor.util.createOrigin().toString()}},href:{get(){return self.$meteor.util.createOrigin().href},set(e){self.$meteor.rewrite.url.encode(e,self.$meteor.util.createOrigin())}},origin:{get(){return self.$meteor.util.createOrigin().origin}},search:{get(){return self.$meteor.util.createOrigin().search},set(e){window.location.search=self.$meteor.config.codec.encode(e)}},hash:{get(){return self.$meteor.util.createOrigin().hash}},pathname:{get(){return self.$meteor.util.createOrigin().pathname},set(e){let t=self.$meteor.util.createOrigin();t.pathname=e,window.location.pathname=self.$meteor.rewrite.url.encode(t.toString(),t)}},protocol:{get(){return self.$meteor.util.createOrigin().protocol},set(){}},host:{get(){return self.$meteor.util.createOrigin().host},set(e){let t=self.$meteor.util.createOrigin();t.host=e,window.location.host=self.$meteor.rewrite.url.encode(t.toString(),t)}},hostname:{get(){return self.$meteor.util.createOrigin().hostname},set(e){let t=self.$meteor.util.createOrigin();t.hostname=e,window.location.hostname=self.$meteor.rewrite.url.encode(t.toString(),t)}},port:{get(){return self.$meteor.util.createOrigin().port},set(){}},replace:{value(e){location.replace(self.$meteor.rewrite.url.encode(e,self.$meteor.util.createOrigin()))}}});globalThis.$location=window.$location;document.$location=window.$location;var W=["cross-origin-embedder-policy","cross-origin-opener-policy","cross-origin-resource-policy","content-security-policy","content-security-policy-report-only","expect-ct","feature-policy","origin-isolation","strict-transport-security","upgrade-insecure-requests","x-content-type-options","x-download-options","x-frame-options","x-permitted-cross-domain-policies","x-powered-by","x-xss-protection","clear-site-data"],j=["host","origin"];function v(e,t,n=Headers){let r=new n;for(let[o,s]of e.entries())r.set(o.toLowerCase(),s);for(let o of W)r.delete(o);for(let o of["referer","location","content-location"])r.set(o,self.$meteor.rewrite.url.encode(r.get(o),t));for(let o of j)r.has(o)&&r.set(o,new URL(self.$meteor.rewrite.url.encode(r.get(o),t))[o]);return r.has("link")&&r.set("link",r.get("link").replace(/<(.*?)>/gi,o=>self.$meteor.rewrite.url.encode(o,t))),r}function F(e,t,n=Headers){let r=new n,o=Array.isArray(e)?e:Object.entries(e);for(let[s,p]of o)r.set(s.toLowerCase(),p);for(let s of W)r.delete(s);for(let s of["referer","location","content-location"]){let p=r.get(s);p&&r.set(s,self.$meteor.rewrite.url.encode(p,t))}for(let s of j){let p=r.get(s);p&&r.set(s,new URL(self.$meteor.rewrite.url.encode(p,t))[s])}return r.has("link")&&r.set("link",r.get("link").replace(/<(.*?)>/gi,s=>self.$meteor.rewrite.url.encode(s,t))),r}function u(e,t){return t||(t=self.$meteor.util.createOrigin()),e instanceof URL?new URL(self.$meteor.rewrite.url.encode(e.toString(),self.$meteor.util.createOrigin())):self.$meteor.rewrite.url.encode(e,self.$meteor.util.createOrigin())}var L=globalThis.Headers;window.fetch=c(window.fetch,e=>{if(e[0]instanceof Request){let t=e[0];e[0]=new Request(self.$meteor.rewrite.url.encode(t.url,self.$meteor.util.createOrigin()),Object.defineProperty(t,"url",{value:void 0}))}else e[0]=u(e[0]);return e});window.XMLHttpRequest.prototype.open=c(XMLHttpRequest.prototype.open,e=>(e[1]instanceof URL?e[1]=new URL(self.$meteor.rewrite.url.encode(e[1].href,self.$meteor.util.createOrigin())):e[1]=self.$meteor.rewrite.url.encode(e[1],self.$meteor.util.createOrigin()),e));window.Request=y(Request,e=>{if(e[0]instanceof Request){let t=e[0];e[0]=new Request(self.$meteor.rewrite.url.encode(t.url,self.$meteor.util.createOrigin()),Object.defineProperty(t,"url",{value:void 0}))}else e[0]=u(e[0]);return e});window.Headers=y(Headers,([e])=>(e instanceof Headers?e=v(new L(e),self.$meteor.util.createOrigin(),L):(Array.isArray(e)||typeof e=="object")&&(e=e=F(e,self.$meteor.util.createOrigin(),L)),[e]));Response.redirect=c(Response.redirect,e=>(e[0]=u(e[0]),e));window.Worker=y(Worker,e=>[u(e[0],self.$meteor.util.createOrigin()),e[1]]);window.Worklet.prototype.addModule=c(Worklet.prototype.addModule,e=>[u(e[0],self.$meteor.util.createOrigin()),e[1]]);window.addEventListener=new Proxy(window.addEventListener,{apply(e,t,[n,r,...o]){return(n==="message"||n==="messageerror")&&(r=c(r,([s])=>(Object.defineProperty(s,"origin",{value:window.$location.origin,writable:!1}),[s]))),n==="hashchange"&&(r=c(r,([s])=>(Object.defineProperty(s,"newURL",{value:self.$meteor.rewrite.url.decode(s.newURL),writable:!1}),Object.defineProperty(s,"oldURL",{value:self.$meteor.rewrite.url.decode(s.oldURL),writable:!1}),[s]))),Reflect.apply(e,t,[n,r,...o])}});var S=([e,,t])=>(t&&(t=u(t)),[e,"",t]);window.history.replaceState=c(window.history.replaceState,S);window.history.pushState=c(window.history.pushState,S);window.History.prototype.replaceState=c(window.History.prototype.replaceState,S);window.History.prototype.pushState=c(window.History.prototype.pushState,S);var J=globalThis.fetch,w=globalThis.WebSocket,K=globalThis.Request,M=globalThis.Response,O=globalThis.SharedWorker,I=globalThis.localStorage,Q=globalThis.navigator.serviceWorker,b={prototype:{send:w.prototype.send},CLOSED:w.CLOSED,CLOSING:w.CLOSING,CONNECTING:w.CONNECTING,OPEN:w.OPEN};async function P(){let t=(await self.clients.matchAll({type:"window",includeUncontrolled:!0})).map(async r=>{let o=await Y(r);return await D(o),o}),n=Promise.race([Promise.any(t),new Promise((r,o)=>setTimeout(o,1e3,new TypeError("timeout")))]);try{return await n}catch(r){if(r instanceof AggregateError)throw console.error("bare-mux: failed to get a bare-mux SharedWorker MessagePort as all clients returned an invalid MessagePort."),new Error("All clients returned an invalid MessagePort.");return console.warn("bare-mux: failed to get a bare-mux SharedWorker MessagePort within 1s, retrying"),await P()}}function Y(e){let t=new MessageChannel;return new Promise(n=>{e.postMessage({type:"getPort",port:t.port2},[t.port2]),t.port1.onmessage=r=>{n(r.data)}})}function D(e){let t=new MessageChannel,n=new Promise((r,o)=>{t.port1.onmessage=s=>{s.data.type==="pong"&&r()},setTimeout(o,1500)});return e.postMessage({message:{type:"ping"},port:t.port2},[t.port2]),n}function N(e,t){let n=new O(e,"bare-mux-worker");return t&&Q.addEventListener("message",r=>{if(r.data.type==="getPort"&&r.data.port){console.debug("bare-mux: recieved request for port from sw");let o=new O(e,"bare-mux-worker");r.data.port.postMessage(o.port,[o.port])}}),n.port}var x=class{constructor(t){this.channel=new BroadcastChannel("bare-mux"),t instanceof MessagePort?this.port=t:this.createChannel(t,!0)}createChannel(t,n){if(self.clients)this.port=P(),this.channel.onmessage=r=>{r.data.type==="refreshPort"&&(this.port=P())};else if(t&&O){if(!t.startsWith("/")&&!t.includes("://"))throw new Error("Invalid URL. Must be absolute or start at the root.");this.port=N(t,n),console.debug("bare-mux: setting localStorage bare-mux-path to",t),I["bare-mux-path"]=t}else if(O){let r=I["bare-mux-path"];if(console.debug("bare-mux: got localStorage bare-mux-path:",r),!r)throw new Error("Unable to get bare-mux workerPath from localStorage.");this.port=N(r,n)}else throw new Error("Unable to get a channel to the SharedWorker.")}async sendMessage(t,n){this.port instanceof Promise&&(this.port=await this.port);try{await D(this.port)}catch{return console.warn("bare-mux: Failed to get a ping response from the worker within 1.5s. Assuming port is dead."),this.createChannel(),await this.sendMessage(t,n)}let r=new MessageChannel,o=[r.port2,...n||[]],s=new Promise((p,a)=>{r.port1.onmessage=f=>{let l=f.data;l.type==="error"?a(l.error):p(l)}});return this.port.postMessage({message:t,port:r.port2},o),await s}};var Z="!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~";function ee(e){for(let t=0;t<e.length;t++){let n=e[t];if(!Z.includes(n))return!1}return!0}var te=["ws:","wss:"],re=[101,204,205,304],oe=[301,302,303,307,308];var E=class{constructor(t){this.worker=new x(t)}createWebSocket(t,n=[],r,o,s){try{t=new URL(t)}catch{throw new DOMException(`Faiiled to construct 'WebSocket': The URL '${t}' is invalid.`)}if(!te.includes(t.protocol))throw new DOMException(`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${t.protocol}' is not allowed.`);Array.isArray(n)||(n=[n]),n=n.map(String);for(let i of n)if(!ee(i))throw new DOMException(`Failed to construct 'WebSocket': The subprotocol '${i}' is invalid.`);let p=r||w,a=new p("ws://127.0.0.1:1",n),f="",l=b.CONNECTING,d=!1;a.addEventListener("error",i=>{d||(l=w.CONNECTING,i.stopImmediatePropagation(),d=!0)});let $=!1;a.addEventListener("close",i=>{$||(i.stopImmediatePropagation(),$=!0)}),s=s||p.constructor.constructor("return ArrayBuffer")().prototype,o=o||{},o.Host=new URL(t).host,o.Pragma="no-cache",o["Cache-Control"]="no-cache",o.Upgrade="websocket",o.Connection="Upgrade";let T=i=>{l=b.OPEN,f=i,a.meta={headers:{"sec-websocket-protocol":i}},a.dispatchEvent(new Event("open"))},B=async i=>{typeof i=="string"?a.dispatchEvent(new MessageEvent("message",{data:i})):"byteLength"in i?(a.binaryType==="blob"?i=new Blob([i]):Object.setPrototypeOf(i,s),a.dispatchEvent(new MessageEvent("message",{data:i}))):"arrayBuffer"in i&&(a.binaryType==="arraybuffer"&&(i=await i.arrayBuffer(),Object.setPrototypeOf(i,s)),a.dispatchEvent(new MessageEvent("message",{data:i})))},G=(i,g)=>{l=b.CLOSED,a.dispatchEvent(new CloseEvent("close",{code:i,reason:g}))},_=()=>{l=b.CLOSED,a.dispatchEvent(new Event("error"))},m=new MessageChannel;m.port1.onmessage=i=>{i.data.type==="open"?T(i.data.args[0]):i.data.type==="message"?B(i.data.args[0]):i.data.type==="close"?G(i.data.args[0],i.data.args[1]):i.data.type==="error"&&_()},this.worker.sendMessage({type:"websocket",websocket:{url:t.toString(),origin,protocols:n,requestHeaders:o,channel:m.port2}},[m.port2]);let C=()=>l;Object.defineProperty(a,"readyState",{get:C,configurable:!0,enumerable:!0});let X=()=>{if(C()===b.CONNECTING)return new DOMException("Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.")};return a.send=function(...i){let g=X();if(g)throw g;let h=i[0];h.buffer&&(h=h.buffer),m.port1.postMessage({type:"data",data:h},h instanceof ArrayBuffer?[h]:[])},a.close=function(i,g){m.port1.postMessage({type:"close",closeCode:i,closeReason:g})},Object.defineProperty(a,"url",{get:()=>t.toString(),configurable:!0,enumerable:!0}),Object.defineProperty(a,"protocol",{get:()=>f,configurable:!0,enumerable:!0}),a}async fetch(t,n){let r=new K(t,n),o=n?.headers||r.headers,s=o instanceof Headers?Object.fromEntries(o):o,p=r.body,a=new URL(r.url);if(a.protocol.startsWith("blob:")){let f=await J(a),l=new M(f.body,f);return l.rawHeaders=Object.fromEntries(f.headers),l.rawResponse=f,l}for(let f=0;;f++){"host"in s?s.host=a.host:s.Host=a.host;let l=(await this.worker.sendMessage({type:"fetch",fetch:{remote:a.toString(),method:r.method,headers:s,body:p||void 0}},p?[p]:[])).fetch,d=new M(re.includes(l.status)?void 0:l.body,{headers:new Headers(l.headers),status:l.status,statusText:l.statusText});d.rawHeaders=l.headers,d.rawResponse=new M(l.body),d.finalURL=a.toString();let $=n?.redirect||r.redirect;if(oe.includes(d.status))switch($){case"follow":{let T=d.headers.get("location");if(20>f&&T!==null){a=new URL(T,a);continue}else throw new TypeError("Failed to fetch")}case"error":throw new TypeError("Failed to fetch");case"manual":return d}else return d}}};var ne=new E,se=globalThis.WebSocket;globalThis.WebSocket=new Proxy(globalThis.WebSocket,{construct(e,t){return self.$meteor_config.debug===!0&&self.$meteor.util.log(`Creating websocket to ${t[0]} on origin ${self.$meteor.util.createOrigin().origin}`,"teal"),ne.createWebSocket(t[0],t[1],se,{"User-Agent":navigator.userAgent,origin:self.$location.origin},ArrayBuffer.prototype)}});Object.defineProperties(window.navigator,{});"sendBeacon"in globalThis.navigator&&(globalThis.navigator.sendBeacon=c(globalThis.navigator.sendBeacon,e=>(e[0]=u(e[0]),e)));"clipboard"in globalThis.navigator&&(globalThis.navigator.clipboard=c(globalThis.navigator.clipboard,e=>(e[0],e)));"serviceworker"in globalThis.navigator&&(globalThis.navigator.serviceWorker=new TypeError("Service Workers are not supported on proxies"));"credentials"in globalThis.navigator&&(globalThis.navigator.credentials=c(globalThis.navigator.credentials,e=>(self.$meteor.util.log(`Attempting to patch: ${e}`,"teal"),e)));var R="meteor$";function q(e){let t=()=>Object.keys(e).filter(n=>n.startsWith(R+window.$location.host));return new Proxy(e,{get(n,r){switch(r){case"setItem":return(o,s)=>n.setItem(`${R}${window.$location.host}@${o}`,s);case"getItem":return o=>n.getItem(`${R}${window.$location.host}@${o}`);case"removeItem":return o=>n.removeItem(`${R}${window.$location.host}@${o}`);case"clear":return()=>{for(let o of t())n.removeItem(o)};case"length":return t().length;case"key":return o=>n[t()[o]]}}})}var ie=q(window.localStorage),ae=q(window.sessionStorage);delete window.localStorage;delete window.sessionStorage;window.localStorage=ie;window.sessionStorage=ae;(async()=>{for(let e of await self.$meteor.util.getEnabledPlugins(window.$location.href,"handleClient"))self.$meteor.util.log(`Running handleClient for ${e.name}`,"teal"),e.handleClient(window)})();})();
//# sourceMappingURL=meteor.client.js.map
